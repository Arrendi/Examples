---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

# Why `replyr`

`replyr` stands for **RE**mote **PLY**ing of big data for **R**.

Why should [R](https://www.r-project.org) users try [`replyr`](https://CRAN.R-project.org/package=replyr)?  Because it lets you take a number of common working patterns and apply them to remote data (such as databases or [`Spark`](https://spark.apache.org)). 

For example: `replyr` allows users to use the following functions on `Spark` data similar to how they are used on local `data.frame`s. Some key capability gaps remedied by `replyr` include:

  * Summarizing data: `replyr_summary()`.
  * Binding tables by row: `replyr_bind_rows()`.
  * Using the split/apply/combine pattern (`dplyr::do()`): `replyr_split()`, `replyr::gapply()`.
  * Pivot/anti-pivot (`gather`/`spread`): `replyr_moveValuesToRows()`/ `replyr_moveValuesToColumns()`.
  * Parametric programming (`wrapr::let()` and `replyr::replyr_apply_f_mapped()`).
  * Handle tracking.

You may have already learned to decompose your local data processing into steps including the above,
so retaining such capabilities makes working with `Spark` and [`sparklyr`](http://spark.rstudio.com) *much* easier.

Below are some examples.

***

# Examples

***

```{r setup}
base::date()
suppressPackageStartupMessages(library("dplyr"))
packageVersion("dplyr")
library("tidyr")
packageVersion("tidyr")
library("replyr")
# either:
#  install.packages("replyr")
# or
#  devtools::install_github('WinVector/replyr')
packageVersion("replyr")
suppressPackageStartupMessages("spaklyr")
packageVersion("sparklyr")

sc <- sparklyr::spark_connect(version='2.0.2', 
                              master = "local")
```

## `summary`

Standard `summary()`,  `glimpse()`, `glance()`, all fail on `Spark`.

```{r sparksummary, error=TRUE}
mtcars_spark <- copy_to(sc, mtcars)

# gives summary of handle, not data
summary(mtcars_spark)

# errors-out
glimpse(mtcars_spark)
```

```{r glance, error=TRUE}
broom::glance(mtcars_spark)
```

`replyr_summary` works.

```{r rsum}
replyr_summary(mtcars_spark) %>%
  select(-lexmin, -lexmax, -nunique, -index)
```

***

## `gather`/`spread`

`tidyr` pretty much only works on local data.

```{r gatherspread, error=TRUE}
mtcars2 <- mtcars %>%
  mutate(car = row.names(mtcars)) %>%
  copy_to(sc, ., 'mtcars2')

# errors out
mtcars2 %>% 
  tidyr::gather('fact', 'value')
```

```{r moveValuesToCols}
mtcars2 %>%
  replyr_moveValuesToRows(nameForNewKeyColumn= 'fact', 
                          nameForNewValueColumn= 'value', 
                          columnsToTakeFrom= colnames(mtcars),
                          nameForNewClassColumn= 'class') %>%
  arrange(car, fact)
```


## `replyr_bind_rows`

`dplyr` `bind_rows`, `union`, and `union_all` are all unsuitable for use on `Spark`.
`replyr::replyr_bind_rows()` supplies a working alternative.

### `bind_rows()`


```{r bindrows, error=TRUE}
db1 <- copy_to(sc, 
               data.frame(x=1:2, y=c('a','b'), 
                          stringsAsFactors=FALSE),
               name='db1')
db2 <- copy_to(sc, 
               data.frame(y=c('c','d'), x=3:4, 
                          stringsAsFactors=FALSE),
               name='db2')

# Errors out as it tries to operate on the handles instead of the data.
bind_rows(list(db1, db2))
```

### `union_all`

```{r uniona, error=TRUE}
# ignores column names and conversts all data to char
union_all(db1, db2)
```

### `union`

```{r union, error=TRUE}
# ignores column names and conversts all data to char
# also will probably lose duplicate rows
union(db1, db2)
```

### `replyr_bind_rows`

`replyr::replyr_bind_rows` can bind multiple `data.frame`s together.

```{r replyr_bind_rows, error=TRUE}
replyr_bind_rows(list(db1, db2))
```

## `dplyr::do`

Our example is just taking a few rows from each group of a grouped data set. 
Note: since we are not enforcing order by an arrange we 
can't expect the results to always match on database
or `Spark` data sources.

### `dplyr::do` on local data

From `help('do', package='dplyr')`:

```{r dplyrdolocal}
by_cyl <- group_by(mtcars, cyl)
do(by_cyl, head(., 2))
```

***

### `dplyr::do` on `Spark`

```{r dplyrdolocalspark}
by_cyl <- group_by(mtcars_spark, cyl)
do(by_cyl, head(., 2))
```

Notice we did not get back usable results.

### `replyr` split/apply

```{r replyrdo}
mtcars_spark %>%
  replyr_split('cyl', 
               partitionMethod = 'extract') %>%
  lapply(function(di) head(di, 2)) %>%
  replyr_bind_rows()
```

### `replyr` gapply

```{r replyrgapply}
mtcars_spark %>%
  gapply('cyl',
         partitionMethod = 'extract',
         function(di) head(di, 2))
```

***

## `wrapr::let`

`wrapr::let` allows execution of arbitrary code with substituted variable names (note this is subtly different than binding values for names as with `base::substitute` or `base::with`).  This allows the user to write arbitrary `dplyr` code in the case of ["parametric variable names"](http://www.win-vector.com/blog/2016/12/parametric-variable-names-and-dplyr/) (that is when variable names are not known at coding time, but will become available later at run time as values in other variables) without directly using the `dplyr` "underbar forms"  (and the direct use of `lazyeval::interp` and `.dots=stats::setNames` to use the `dplyr` "underbar forms").

Example:

```{r  message=FALSE,results='hide',warning=FALSE}
library('dplyr')
```
```{r letexample}
# nice parametric function we write
ComputeRatioOfColumns <- function(d,NumeratorColumnName,DenominatorColumnName,ResultColumnName) {
  wrapr::let(
    alias=list(NumeratorColumn=NumeratorColumnName,
               DenominatorColumn=DenominatorColumnName,
               ResultColumn=ResultColumnName),
    expr={
      # (pretend) large block of code written with concrete column names.
      # due to the let wrapper in this function it will behave as if it was
      # using the specified paremetric column names.
      d %>% mutate(ResultColumn = NumeratorColumn/DenominatorColumn)
    })
}

# example data
d <- data.frame(a=1:5, b=3:7)

# example application
d %>% ComputeRatioOfColumns('a','b','c')
```

`wrapr::let` makes construction of abstract functions over `dplyr` controlled data much easier.  It is designed for the case where the "`expr`" block is large sequence of statements and pipelines.

`wrapr::let` is based on `gtools::strmacro` by Gregory R. Warnes.

## `replyr::replyr_apply_f_mapped`

`wrapr::let` was only the secondary proposal in the original [2016 "Parametric variable names" article](http://www.win-vector.com/blog/2016/12/parametric-variable-names-and-dplyr/).  What we really wanted was a stack of view so the data pretended to have names that matched the code (i.e., re-mapping the data, not the code).  

With a bit of thought we can achieve this if we associate the data re-mapping with a function environment instead of with the data.  So a re-mapping is active as long as a given controlling function is in control.  In our case that function is `replyr::replyr_apply_f_mapped()` and works as follows:

Suppose the operation we wish to use is a rank-reducing function that has been supplied as function from somewhere else that we do not have control of (such as a package).  The function could be simple such as the following, but we are going to assume we want to use it without alteration (including the without the small alteration of introducing `wrapr::let()`).

```{r rankfn}
# an external function with hard-coded column names
DecreaseRankColumnByOne <- function(d) {
  d$RankColumn <- d$RankColumn - 1
  d
}
```

To apply this function to `d` (which doesn't have the expected column names!) we use  `replyr::replyr_apply_f_mapped()` as follows:

```{r replyrmapf}
d <- data.frame(Sepal_Length = c(5.8,5.7),
                Sepal_Width = c(4.0,4.4),
                Species = 'setosa',
                rank = c(1,2))

# map our data to expected column names so we can use function
nmap <- c(GroupColumn='Species',
          ValueColumn='Sepal_Length',
          RankColumn='rank')
print(nmap)

dF <- replyr::replyr_apply_f_mapped(d, DecreaseRankColumnByOne, nmap,
                                    restrictMapIn = FALSE, 
                                    restrictMapOut = FALSE)
print(dF)
```

`replyr::replyr_apply_f_mapped()` renames the columns to the names expected by `DecreaseRankColumnByOne` (the mapping specified in `nmap`), applies `DecreaseRankColumnByOne`, and then inverts the mapping before returning the value.

***

## Handle management

A lot of `Spark` tasks involve creation of intermediate or temporary tables.  This can
be explicitly (through `dplyr::copy_to()`) and implicit (through `dplyr::compute()`).
These handles can represent a reference leak.  To deal with this `replyr` supplies 
record-retaining temporary name generators (and uses the same internally).

For instance to join a few tables it is a good idea to call compute after each 
join (else the generated `SQL` can become large and unmanageable).  This sort of code
looks like the following:

```{r joinlist}
# create example data
names <- paste('table', 1:5, sep='_')
tables <- lapply(names, 
                 function(ni) {
                   di <- data.frame(key= 1:3)
                   di[[paste('val',ni,sep='_')]] <- runif(nrow(di))
                   copy_to(sc, di, ni)
                 })

# build our temp name generator
tmpNamGen <- replyr::makeTempNameGenerator('JOINTMP')
# left join the tables in sequence
joined <- tables[[1]]
for(i in seq(2,length(tables))) {
  ti <- tables[[i]]
  if(i<length(tables)) {
    joined <- compute(left_join(joined, ti, by='key'),
                    name= tmpNamGen())
  } else {
    joined <- compute(left_join(joined, ti, by='key'),
                    name= 'joinres')
  }
}

# clean up temps
temps <- tmpNamGen(dumpList = TRUE)
print(temps)
for(ti in temps) {
  db_drop_table(sc, ti)
}

# show result
print(joined)
```

Careful introduction and management of materialized intermediates can conserve resources
and greatly improve outcomes.

***

# Conclusion

If you are serious about `R` controlled data processing in `Spark` you should seriously consider using `replyr` in addition to [`dplyr`](https://CRAN.R-project.org/package=dplyr) and `sparklyr`.

```{r cleanup}
sparklyr::spark_disconnect(sc)
rm(list=ls())
gc()
```
